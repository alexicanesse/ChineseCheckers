<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChineseCheckers: Chinese Checkers Solver using Alpha Beta pruning in C++: Project Report</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ChineseCheckers
   </div>
   <div id="projectbrief">This project is a solver for two players&#39; Chinese Checkers game using the Alpha Beta pruning algorithm. The program is written in C++ and uses a number of heuristics to improve the performance of the algorithm. Overall, the Chinese Checkers solver program has been built with performance in mind, and is designed to deliver fast and efficient game play. Whether you are playing against a bot or using the program as a library in your own project, you can be confident that the program will deliver high-performance results.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_p_o_r_t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chinese Checkers Solver using Alpha Beta pruning in C++: Project Report </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Ce projet est une IA pour le jeu de dames chinoises pour deux joueurs utilisant l'algorithme d'élagage Alpha Beta. Le but de ce rapport est de fournir une vue d'ensemble du projet, d'expliquer l'organisation et l'utilisation du code, de discuter des défis rencontrés et de fournir une analyse des résultats obtenus.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Sommaire</h1>
<ul>
<li>Vue d'ensemble</li>
<li>Règles du jeu<ul>
<li>Mouvements</li>
<li>Positions illégales</li>
</ul>
</li>
<li>Organisation du code</li>
<li>Heuristiques<ul>
<li>Ouvertures</li>
<li>Tri</li>
<li>Coupure de l'arbre</li>
<li>Zero-width Window Search</li>
<li>Table de transposition</li>
</ul>
</li>
<li>Evaluation par algorithme génétique<ul>
<li>Présentation de l'algorithme</li>
<li>Implémentation</li>
<li>Résultats</li>
</ul>
</li>
<li>Optimisation</li>
<li>Interface graphique</li>
<li>Libraries nécessaires</li>
<li>Compiler<ul>
<li>Installer les libraries</li>
<li>Compiler</li>
</ul>
</li>
<li>Jouer</li>
<li>Résultats obtenus</li>
<li>Difficultées rencontrées</li>
</ul>
<h1><a class="anchor" id="autotoc_md41"></a>
Vue d'ensemble</h1>
<p>Le projet a été conçu pour être aussi performant que possible tout en restant assez portable. Le cœur du jeu a été pensé pour être facilement intégré dans n'importe quel autre projet : la librarie est rapide et offre toutes les fonctionnalités nécessaires. L'interface graphique est indépendante et pourrait être adaptée pour fonctionner avec n'importe quel solver et n'importe quel cœur du jeu. Le solver est d'un haut niveau (sur-humain!) et inclu de nombreuses heuristiques permettant d'accélérer son fonctionnement.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Règles du jeu</h1>
<p>Les Dames Chinoises sont un jeu pour 2 joueurs en tour à tour. Chacun sous tour, les joueurs bougent un de leurs 10 pions, le but est d'être le premier à remplir la zone de départ adverse avec au moins un de ses pions.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Mouvements</h2>
<p>Pour bouger un pion il y a deux possibilités :</p><ul>
<li>le déplacer vers une case adjacente</li>
<li>sauter par-dessus un pion, pour cela si le pion est à <em>n</em> cases vides d'un autre pion et que les <em>n+1</em> cases symétriques par rapport à ce pion sont également libres, alors le pion peut être placé sur la <em>n+1</em>-ème case symétrique. Lorsqu'un pion saute par-dessus un autre, il peut continuer à bouger tant que les prochains mouvements sont également des sauts</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
Positions illégales</h2>
<p>Pour éviter de l'antijeu de la part d'un joueur, nous avons établi des positions illégales. Une position est considérée illégale si une ou plusieurs cases libres de la zone de départ d'un des joueurs est inaccessible pour tout pion adverse. Une case est inaccessible lorsque, en donnant une infinité de coups d'affilée au joueur adverse, les pions ne peuvent pas se placer sur cette case.</p>
<p>Une étude plus précise des positions illégales est disponible dans le document <a href="illegal_states.pdf">illegal_states.pdf</a>.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Organisation du code</h1>
<p>Les bibliothèques partagées <code>libChineseCheckers</code> et <code><a class="el" href="class_alpha_beta.html" title="The AlphaBeta class inherits from the ChineseCheckers class and provides an implementation of the alp...">AlphaBeta</a></code> sont les composantes principales. Elles peuvent être utilisées pour interagir avec la logique principale du jeu et le résolveur dans d'autres projets, en C++ et en Python. Tous les autres composants sont indépendants entre eux et n'utilisent que ces libraries.</p>
<p>Ce projet contient aussi quatre executables. Iceux sont utilisés pour développer certaines fonctionnalités. Il y en a un utilisé pour faire des benchmarks, un pour améliorer l'évaluation à l'aide d'algorithmes génétiques, un pour générer les données nécessaire à l'entrainement de l'intuition et enfin un pour créer un livre d'ouvertures.</p>
<p>Enfin, le projet contient une belle interface graphique crée en python. Elle permet d'interagir avec notre solver et le cœur du jeu. Elle inclut quelques fonctionnalités propres telle que l'affichage des coups possibles.</p>
<p>Afin de bien comprendre le code, nous vous invitons à visiter le <a href="https://alexicanesse.github.io/ChineseCheckers/html/index.html">site du projet</a> qui regroupe des explications détaillées de toute l'implémentation C++.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Heuristiques</h1>
<p>Nous avons progressivement implémenté diverses heuristiques pour améliorer le niveau de jeu de notre IA. Nous avons également utilisé des techniques d'apprentissage automatique pour affiner nos heuristiques en fonction des résultats obtenus lors de nos tests et de nos matchs contre d'autres joueurs. Grâce à ces améliorations continues, notre IA est capable de jouer à un niveau très élevé et de rivaliser avec les meilleurs joueurs que nous avons pu trouver.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Ouvertures</h2>
<p>Le début d'une partie est très important. Pour de bons joueurs, une ouverture de qualité peu être décisive. Nous avons donc pré-calculé toutes les ouvertures possibles sur au moins 4 tours à l'aide de notre IA en haute profondeur. En limitant la largeur de l'arbre de recherche, nous avons aussi calculé un 5ème voir 6ème tour pour les variations principales (ie celles où l'adversaire joue de bons coups).</p>
<p>Ce calcul est très coûteux, c'est pourquoi nous l'avons parallélisé avec succès pour augmenter la vitesse de calcul. Nous avons ainsi pu bénéficier des avantages du calcul en haute profondeur pour les ouvertures de partie, ce qui nous donne un avantage décisif sur nos adversaires!</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Tri</h2>
<p>L'ordre des coups est crucial pour deux raisons :</p><ul>
<li>Tout d'abord, plus les premiers coups sont de qualité, plus il y aura d'élagages et donc de meilleures performances. Cela peut réduire considérablement le temps de calcul nécessaire.</li>
<li>Ensuite, si deux coups ont la même évaluation, le premier des deux est renvoyé. Ainsi, l'ordre dans lequel les coups sont examinés peut faire la différence entre une victoire et une défaite.</li>
</ul>
<p>Nous avons deux méthodes de tri : une basée sur un réseau de neurones et l'autre sur une fonction linéaire de comparaison. Les deux méthodes sont très performantes : dans la plupart des cas, le meilleur coup est classé premier, et même dans les exceptions, il est au pire classé cinquième parmi les 40 à 100 coups possibles.</p>
<p>Cependant, pour des raisons techniques, nous ne pouvons utiliser le réseau de neurones que sur la première couche de l'arbre. En effet, les structures de données optimisées que nous utilisons ne sont pas compatibles avec notre réseau. Convertir les données a un coût, et l'utilisation du réseau sur toutes les couches de l'arbre augmente considérablement le temps de calcul. Nous espérons améliorer ce résultat en consacrant plus de temps au réseau à l'avenir. Malgré cela, utiliser le réseau sur la première couche permet de gagner quelques pourcentages de temps de calcul.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Coupure de l'arbre</h2>
<p>Dans notre algorithme, nous avons choisi d'explorer qu'un nombre limité de coups possibles à chaque étape. Cela nous permet de réduire la largeur de l'arbre de recherche et donc de limiter le temps de calcul nécessaire pour évaluer une position donnée. En limitant le nombre de coups explorés, nous sommes en mesure d'obtenir des résultats de qualité en un temps raisonnable.</p>
<p>Lorsque nous explorons les coups possibles, nous les classons selon une heuristique spécifique qui nous permet de sélectionner les meilleurs coups en premier. Cette heuristique est efficace dans la plupart des cas, ce qui signifie que même si le premier coup n'était pas assez bien classé pour être évalué, nous jouons tout de même un très bon coup.</p>
<p>Une coupure assez grossière, de l'ordre de 10 ou 15 coups par exemple, permet de beaucoup gagner en profondeur et de jouer en profondeur 8 par exemple. En effet, en coupant à une profondeur plus élevée, nous réduisons considérablement le nombre de coups que nous devons explorer. Cela nous permet d'atteindre une plus grande profondeur de recherche avec un temps de calcul similaire.</p>
<p>Une IA en profondeur 8 qui n'évalue que les 10 meilleurs coups à chaque fois gagne avec un bel avantage contre une IA en profondeur 5 qui évalue tous les coups et pourtant les deux ont des temps de calcul similaire. Ainsi, la qualité suffisante du tri permet de beaucoup gagner en qualité de jeu.</p>
<p>Cette heuristique présente un défaut : il y a un hyperparamètre qu'il est important de régler de manière judicieuse. Pour le moment, il a été réglé manuellement, ce qui n'est pas optimal. Le développement d'une bonne évaluation du niveau de jeu permettra de mieux régler ces hyperparamètres.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Zero-width Window Search</h2>
<p>Cette heuristique permet d'identifier rapidement un coup dont l'évaluation est connue, s'il existe, en se basant sur un grand nombre d'élagages. Un algorithme personnalisé basé sur cette heuristique a considérablement amélioré le niveau de jeu de l'IA en fin de partie, tout en réduisant considérablement le temps de calcul.</p>
<p>Lorsque l'IA évalue un coup à -\infty à un moment donné de la partie, cela signifie qu'il existe une suite de coups menant à une victoire certaine à une profondeur inférieure à celle de l'arbre de recherche. Une fois qu'une victoire certaine est détectée, lorsqu'un coup est calculé, on lance une recherche de fenêtre de largeur nulle avec alpha = -\infty = beta à des profondeurs de 1, 3, 5, etc., jusqu'à ce qu'un coup soit trouvé. Étant donné que la victoire a été détectée, on sait que cela se terminera en peu de coups. Cette méthode garantit une victoire en un minimum de coups en fin de partie. D'une certaines manière, c'est un parcourt en largeur.</p>
<p>Cette heuristique est sans aucun doute celle qui a le plus contribué à améliorer le niveau de jeu de notre IA. Avant son implémentation, les fins de partie étaient de mauvaise qualité et l'IA jouait de manière aléatoire. Maintenant, les fins de partie sont de très bonne qualité et cela est très agréable à voir.</p>
<p>A haute profondeur cet algorithme est vraiment redoutable.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Table de transposition</h2>
<p>En évaluant un arbre en profondeur, on remarque que de nombreuses positions se répètent. Par exemple, effectuer un coup A puis un coup B ou effectuer le coup B puis le coup A mène au même plateau.</p>
<p>Ainsi conserver les résultats des évaluations permet d'éviter de reproduire <em>beaucoup</em> de calculs. L'utilisation de cette table de transposition est très rentable et permet de gagner beaucoup en performances.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Evaluation par algorithme génétique</h1>
<h2><a class="anchor" id="autotoc_md53"></a>
Présentation de l'algorithme</h2>
<p>Une partie essentielle de l'algorithme Alpha Beta est la capacité d'évaluer une position. Il n'existe pas de fonction d'évaluation parfaite pour le jeux des dames chinoises. Bien qu'il soit possible de proposer des fonctions d'évaluations basées sur des distances, rien ne permet de s'assurer que ces fonctions d'évaluations soient efficaces. Des tests rapides montrent que des petits changements dans la fonction d'évaluation changent grandement l'efficacité d'un solveur. Pour obtenir un très bon niveau de jeu, il faut donc chercher une fonction d'évaluation très efficace.</p>
<p>Une méthode classique pour cela est de se fier à l'avis des experts. Par exemple, aux échecs, il existe une théorie très développée du jeu qui permet d'établir de bonnes fonctions d'évaluations. Le jeu des dames chinoises n'est pas aussi populaire que les échecs et une telle théorie n'existe pas. De plus, même aux échecs la théorie n'est pas parfaite puisqu’à chaque nouvelle IA très performante, la valeur associée à chaque pièce change. Pour chercher une bonne fonction d'évaluation il semble donc nécessaire de laisser l'ordinateur la découvrir à l'aide d'une procédure non supervisée.</p>
<p>La procédure que l'on a implémentée est un algorithme génétique. Un algorithme génétique s'inspire de la théorie de l'évolution pour résoudre des problèmes d'optimisation. Pour cela, une population de solveurs est créée. Ces derniers sont alors mis en compétition les un contre les autres. Ceux qui performent le mieux sont ainsi sélectionnés et pourront se reproduire pour former la génération suivante. Entre chaque génération, les individus mutent, ce qui permet l’émergence de stratégies nouvelles.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Implémentation</h2>
<p>Pour ce projet, nous avons décidé d’entraîner deux espèces de solveurs. Une espèce jouant les pions blancs et une espèce jouant les pions noirs. Les espèces sont entraînées par alternance, les pions blancs évoluent contre le meilleur solveur noir puis inversement. Cette méthode d'évolution permet de jouer une seule partie par solveur pour chaque génération, ce qui accélère grandement la vitesse d'une génération. Cela permet aussi de calculer des fonctions d'évaluations plus robustes. Lorsqu'on entraîne des solveurs contre une seule fonction d'évaluation, ils vont être en mesure de battre cette dernière. Cependant, rien ne garantit qu'ils soient efficaces contre un grand nombre de stratégies différentes. C'est pourquoi il est nécessaire de faire évoluer les deux types de solveurs conjointement pour obtenir des stratégies efficaces.</p>
<p>Pour représenter un individu dans un algorithme génétique, il faut pouvoir le représenter sous forme de gènes, une séquence d'information. Pour ce projet, les fonctions d'évaluations correspondent à deux matrices. En représentant ces matrices dans un vecteur de taille 64, on obtient une description génétique des différents solveurs qui comporte deux gènes. On peut alors implémenter les fonctions de mutation et de reproduction. Les mutations sont faites composante par composante. Pour chaque composante, avec probabilité fixée on perturbe la composante par une variable gaussienne d'écart-type fixé. La reproduction se fait par crossing-over. Le crossing over permet de créer un descendant en fonction de deux parents. Pour ce faire, les gènes des parents sont mélangés aléatoirement pour former les gènes du descendant. Cette étape n'est pas nécessaire pour assurer l'évolution du modèle mais elle est connue pour l’accélérer grandement.</p>
<p>Chaque génération peut prendre du temps à être calculée. En particulier, chaque solveur doit jouer une partie, ce qui peut être très long. Afin d’accélérer grandement la vitesse de chaque génération un soin particulier a été réalisé pour pouvoir jouer les parties en parallèle. Le code proposé permet donc de lancer l'algorithme génétique sur plusieurs threads. Le gain de temps est considérable et permet dans certain cas de multiplier par 4 la taille de la population.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Résultats</h2>
<p>L'algorithme génétique à été lancé pour entraîner des matrices en profondeur 1 sur 20 000 générations d'une population de 400 individus. Le nombre de parties jouées s’élève donc à 8 000 000. Les matrices obtenues sont très satisfaisantes. En profondeur 3, elles sont capables de battre la meilleure matrice que nous avons déterminée à la main. Ce résultat est très encourageant, avec plus de temps d'entrainement, il serait alors possible d'entrainer efficacement une matrice à profondeur plus grandee et ainsi améliorer grandement le niveau de jeu.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Optimisation</h1>
<p>L'algorithme alpha-beta a une complexité exponentielle en la profondeur de la recherche. Cela signifie qu'il est crucial d'avoir un code optimisé pour augmenter la profondeur de recherche et ainsi améliorer la qualité des coups. A la find du premier semestre, nous ne pouvions jouer confortablement qu'en profondeur 3. Mais grâce à une refonte totale de notre code et à l'utilisation de structures de données optimisées, nous avons réussi à augmenter considérablement la profondeur de recherche.</p>
<p>Notre première implémentation utilisait beaucoup de tableaux et d'opérations simples. C'était un code facile à comprendre qui a permis d'avoir un code fiable. Néanmoins cela n'était pas assez performant. Nous profitons maintenant plainement du fait que le plateau contient 64 cases afin de le représenter sur des entiers sur 64 bits. Toutes les opérations sont effectuées à l'aide d'opération bit à bit : ce qui est le plus rapide sur un CPU. Faire cette migration était très long, mais le résultat est incroyable. Nous avons également optimisé toutes nos autres structures de données. Nous utilisons également une meilleure fonction de hash : la fonction de hash de Zobrist. Icelle est bonne d'un point de vue cryptographique (nécessaire pour obtenir de bonnes performances avec une table de hash) et ne nécessite que deux opérations XOR pour obtenir le hash après un coup.</p>
<p>Nous avons également utilisé un désassembleur et des outils de profilage afin de faire des options avancées. Cela devenait nécessaire pour encore gagner en performances.</p>
<p>Entre les optimisations de bas niveau et les heuristiques implémentées nous avons énormément gagné en performances. Au premier semestre il fallait quelques centaines de milliseconds pour obtenir un coup en profondeur 3. Maintenant il ne faut que 3 millisecondes pour cela. En profondeur 5 il n'en faut que 5. Enfin, en profondeur 8 nous restons confortablement sous les 200 millisecondes !</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Interface graphique</h1>
<p>L'interface graphique originelle rappelait les heures les plus glorieuses de Windows 98 :</p>
<p><img src="images_rapport/old.png" alt="Windows 98" class="inline"/></p>
<p>La nouvelle, bien plus complète et visuellement plaisante, a intégré de nombreuses fonctionnalités supplémentaires nécessitant un code bien structuré et de nombreuses classes :</p>
<p><img src="images_rapport/during_game.png" alt="nouveau" class="inline"/></p>
<p>Comme nouvelles fonctionnalités, on peut citer par exemple :</p>
<ul>
<li>Possibilité de choisir les paramètres de la partie (qui contre qui, profondeur de l'IA...).</li>
<li>Possibilité de relancer une partie sans redémarrer le programme.</li>
<li>Possibilité d'annuler un coup courant de manière intuitive avec un bouton (avant, il fallait remettre le pion à sa position originelle pour que le coup soit annulé).</li>
<li>Possibilité, en cliquant sur un pion (quel qu'il soit), de voir les cases où il peut atterir.</li>
<li>Possibilité de redimensionner la fenêtre.</li>
</ul>
<p>Et comme nouveautés visuelles :</p>
<ul>
<li>Color scheme repris sur le site chess.com</li>
<li>Indication de qui joue contre qui, et à qui est-ce le tour</li>
<li>Possibilité de voir le parcours d'une pièce déplacée grâce à des flèches</li>
<li>L'interface est plus "interactive" : elle réagit plus aux événements déclenchés par l'utilisateur. En effet, les boutons changent de couleur quand ils sont survolés (sauf s'ils sont grisés), de même pour</li>
<li>le menu de choix de joueur en haut à gauche et les options à cocher, le bouton New Game se grise si la</li>
<li>sélection de joueurs n'est pas valide, etc</li>
</ul>
<p>Côté code, cela se traduit par une séparation claire de l'interface en trois parties :</p>
<p><img src="images_rapport/scene.png" alt="séparation" class="inline"/></p>
<p>À gauche se trouve un objet Canvas Tkinter contenant les objets de la zone des paramètres. Au milieu, un autre Canvas contrôle l'affichage de la partie. À droite (une fois n'est pas coutume), un Canvas contrôle l'affichage des "contrôles".</p>
<p>Le fichier <code>ChineseCheckers_Areas.py</code> contient des constantes graphiques du programme (couleurs, polices). <code>ChineseCheckers_Buttons.py</code> contient des ré-implémentations de boutons Tkinter (car ceux présents dans le module sont moches : impossible par exemple d'enlever un contour noir autour du bouton). Il contient également une réimplémentation de menus Tkinter : celui en haut à gauche permettant le choix des joueurs. Le fichier <code>ChineseCheckers_Board.py</code> gère les canvas mentionnés plus haut. <code>ChineseCheckers_Players.py</code> contient des objets représentant les joueurs (AI et humain). Enfin, <code>ChineseCheckers.py</code> contient le <code>main</code> et une classe <code>Board</code> contrôlant les différents canevas.</p>
<p>Pour ce qui est des boutons, leur fonctionnement peut se comprendre à l'aide de graphes d'états, permettant de choisir l'image affichée lorsque l'utilisateurice passe sa souris dessus, clique dessus,... pour pemettre un rendu agréable.</p>
<p><img src="images_rapport/graphe_bouton_next_turn.png" alt="Alt text" title="Le graphe de transition d&apos;états pour le bouton Next Turn" class="inline"/></p>
<p>Sur le schéma ci-dessus, nous voyons par exemple comment le bouton <code>Next Turn</code> fonctionne. Ainsi :</p><ul>
<li>Il est par défaut grisé (configuration <code>Grayed</code>) ; l'utilisateurice ne peut pas l'utiliser. Dans ce cas, peu importe ce que fera l'utilisateurice, le bouton restera grisé.</li>
<li>S'il est possible de passer au tour suivant (donc soit l'AI vient de jouer, soit l'utilisateurice a bougé un de ses pions), le bouton est en configuration <code>Normal</code>.</li>
<li>Si le bouton est survolé par la souris de l'utilisateurice alors qu'il était en configuration <code>Normal</code>, il rentre en configuration <code>Hovered</code> : l'utilisateurice est averti.e que sa souris survole le bouton.</li>
<li>En configuration <code>Hovered</code>, il y a deux possibilités : soit la souris part du bouton (l'utilisateurice l'a juste survolé, sans cliquer dessus) et il revient en configuration <code>Normal</code>, soit l'utilisateurice clique sur le bouton, ce qui le fait passer en configuration <code>Pressed</code>.</li>
<li>En configuration <code>Pressed</code>, le bouton va directement repasser en configuration <code>Hovered</code> : le clic a duré un instant, et la souris reste ensuite sur le bouton.</li>
</ul>
<h1><a class="anchor" id="autotoc_md58"></a>
Libraries nécessaires</h1>
<p>Certaines libraries sont nécessaire pour pouvoir lancer l'IA :</p><ul>
<li><a href="https://pypi.org/project/pip/">pip3</a></li>
<li><a href="https://numpy.org">Numpy</a></li>
<li><a href="https://www.boost.org/">Boost</a></li>
<li><a href="https://www.boost.org/doc/libs/1_72_0/libs/python/doc/html/index.html">Boost.Python</a></li>
<li><a href="https://docs.python.org/3/library/tkinter.html">Tkinter</a></li>
<li><a href="https://www.tensorflow.org/install/lang_c">Tensorflow C API</a></li>
<li><a href="https://github.com/serizba/cppflow">Cppflow</a></li>
</ul>
<p>Les deux autres libraries ne sont utilises que pour lancer les testes automatiques et les benchmarks.</p><ul>
<li><a href="https://github.com/google/googletest">GoogleTest</a></li>
<li><a href="https://github.com/google/benchmark">Google Benchmark</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md59"></a>
Compiler</h1>
<h2><a class="anchor" id="autotoc_md60"></a>
Installer les libraries</h2>
<p>Sur Ubuntu et les distributions basées sur Debian, les commandes suivantes permettent d'installer tous les outils nécessaires. (Ceci a été vérifié sur une installation vierge d'Ubuntu 22.04. Les particularités de votre installation pourrait néanmoins causer des soucis. Je vous invite à contacter un membre du groupe en case de soucis.) </p><div class="fragment"><div class="line"># CMake</div>
<div class="line">sudo apt install cmake</div>
<div class="line"># g++ (Or any other C++ compiler that supports C++-20.</div>
<div class="line">sudo apt install build-essential</div>
<div class="line">sudo apt install g++-12</div>
<div class="line"># pip3</div>
<div class="line">sudo apt install python3-pip</div>
<div class="line"># Numpy</div>
<div class="line">pip3 install numpy</div>
<div class="line"># Boost</div>
<div class="line">sudo apt install libboost-all-dev</div>
<div class="line"># Tkinter</div>
<div class="line">sudo apt install python3-tk</div>
<div class="line"># Google Test</div>
<div class="line">sudo apt install libgtest-dev</div>
<div class="line"># Google Benchmark</div>
<div class="line">sudo apt install libbenchmark-dev</div>
<div class="line"># Tensorflow C API</div>
<div class="line">FILENAME=libtensorflow-cpu-linux-x86_64-2.11.0.tar.gz</div>
<div class="line">wget -q --no-check-certificate https://storage.googleapis.com/tensorflow/libtensorflow/${FILENAME}</div>
<div class="line">sudo tar -C /usr/local -xzf ${FILENAME}</div>
<div class="line"># cppflow</div>
<div class="line">git clone https://github.com/serizba/cppflow</div>
<div class="line">cd cppflow</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">make -j</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Compiler</h2>
<p>Utilisez les sources envoyées ou clonez le repo gitHub. Créez un dossier <code>bin</code> (attention, le nom de ce dossier est important.). Lancer les deux commandes suivantes</p>
<div class="fragment"><div class="line">cmake -B ./bin -S .</div>
<div class="line">cmake --build ./bin</div>
</div><!-- fragment --><p>Félicitation, vous disposez maintenant d'une configuration minimale!</p>
<p>Il est néanmoins possibles d'ajouter d'autres modules à la compilation. </p><div class="fragment"><div class="line"># Pour ajouter les testes automatiques de la libraries, lancez les commandes suivantes.</div>
<div class="line">cmake -B ./bin -S . -DTEST_ENABLED=ON</div>
<div class="line"> </div>
<div class="line"># Pour ajouter les benchmarks, utilisez</div>
<div class="line">cmake -B ./bin -S . -DBENCHMARK_ENABLED=ON</div>
<div class="line"> </div>
<div class="line"># Pour ajouter l&#39;évolution génétique, utilisez</div>
<div class="line">cmake -B ./bin -S . -DTOURNAMENT_ENABLED=ON</div>
<div class="line"> </div>
<div class="line"># Pour ajouter l&#39;executable générant les données pour le réseau de neuronnes, utilisez</div>
<div class="line">cmake -B ./bin -S . -DINTUITION_DATA_GENERATOR_ENABLED=ON</div>
<div class="line"> </div>
<div class="line"># Pour ajouter l&#39;executable responsable du calcule des ouvertures, utilisez,</div>
<div class="line">cmake -B ./bin -S . -DOPENINGS_GENERATOR_ENABLED=ON</div>
<div class="line"> </div>
<div class="line"># Enfin, utilisez la commande suivante pour relancer une compilation.</div>
<div class="line">cmake --build ./bin</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md62"></a>
Jouer</h1>
<p>Pour jouer, il est nécessaire d'au minimum disposer d'une configuration minimale. Pour cela, voir Compiler.</p>
<p>Pour lancer une partie, lancez <code>ChineseCheckers.py</code> à l'aide de python3. Suivant votre système la commande a utilisez et l'une des deux </p><div class="fragment"><div class="line">python3 ChineseCheckers.py</div>
<div class="line">python3.11 ChineseCheckers.py</div>
</div><!-- fragment --><p>Sur certains sytèmes, lancer l'interface graphique avec <code>python3</code> ne fonctionne pas. Cela est dû a des conflits de libraries. C'est par exemple le cas sur macOS. Sur une installation vierge de Ubuntu 22.04, utiliser <code>python3</code> est fonctionnel.</p>
<p>Il est aussi possible d'utiliser le script <code>partieAutomatique.py</code> pour lancer une partie automatique entre deux bots. Ce script est utile pour faire des benchmarks rapides et vérifier que le comportement n'est pas changé lors de changements dans le code. Un hyper-paramètre au tout début du script permet de régler la profondeur de chaque joueur afin de voir l'impact de la profondeur.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Difficultés rencontrées</h1>
<p>Jusqu'à il y a quelques semaines, nous avions un gros problème de qualité de jeu en fin de parti. C'est un problème inherent à l'algorithme alpha-beta. En effet, une fois qu'une victoire est détectée, l'algorithme ne joue pas forcément de manière à gagner en un nombre minimal de coups et jouais alors n'importe comment, car chaque coup était gagnant. Nous avons finalement réussi à mettre au point un algorithme capable de détecter ces situations et calculer une victoire en un nombre minimal de coup de manière très rapide. C'était un problème très frustrant, parce que nous comprenions sa source, mais il était difficile à régler de façon satisfaisante.</p>
<p>La refonte des structures de données était un défi. Cela a nécessité de reprendre l'intégralité du code. Les opérations bit-à-bit ne sont pas intuitives et sources de nombreuses erreurs. Heureusement nous avions conçu une bonne suite de <em>unittests</em> qui ont permis d'identifier les erreurs et ont beaucoup accéléré le processus tout en assurant que le nouveau code était bon.</p>
<p>L'étude des règles du jeu a posé quelques difficultés dû à l'efficacité que doit avoir leur implémentation. C'est principalement la détection de positions illégales qui a posé problème, bien qu'une bonne partie a pu se faire en pré-calcul, il y a avait besoin d'une transformation trop coûteuse pour les détecter, et, cette détection se faisant à chaque coup, tout le programme en aurait été ralentit. Nous avons donc du trouver une manière d'avoir un premier test moins coûteux qui se fait à chaque coup et un vrai test exhaustif qui ne se fait que lorsque c'est absolument nécessaire.</p>
<p>Niveau interface, deux difficultés principales se sont présentées :</p>
<ol type="1">
<li>Les boutons et menus Tkinter sont moches et peu personnalisables. Il a donc fallu tout recoder, ce qui a pris du temps et des centaines de lignes de code</li>
<li>Faire une fenêtre redimensionnable avec Tkinter n'est pas simple : outre les mises à jour de constantes (taille de l'écran, de la fenêtre, etc), il a fallu personnaliser un certain nombre de comportements : par exemple, les boutons à droite et les pions sont techniquement des rectangles (resp. cercles) Tkinter qui par défaut agissent de la même manière. Cependant, un bouton ne doit pas être redimensionné lorsque la fenêtre l'est, alors qu'un pion doit l'être. Aussi, lorsqu'on créé un texte, sa position est centrée en les coordonnées qu'on indique, mais quand on le bouge pour s'adapter à la nouvelle taille de la fenêtre, il faut indiquer à Tkinter les coordonnées de son coin supérieur gauche (pourquoi ??)</li>
</ol>
<p>En bref, les difficultés graphiques proviennent du choix de Tkinter : peut-être d'autres modules ou projets issus de Tkinter permettent de résoudre ces problèmes.</p>
<p>Maë : Un peu difficile de se rendre véritablement utiles vus les écarts de niveau entre les membres du groupe ; j'ai passé un certain temps à essayer de comprendre différents outils utilisés dans le code ; et j'ai fait en plusieurs heures ce qui ne prenait qu'une demi-heure aux autres. J'ai appris beaucoup de choses, ceci dit ! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
